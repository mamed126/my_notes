
CREATE TABLE [dbo].[CUSTOMER](
[ID] [int] IDENTITY(1,1),
	[CUSTOMERNAME] [varchar](100) ,
	[CITY] [varchar](50) ,
	[DISTRICT] [varchar](50) ,
	[BIRTHDATE] [date] ,
	[GENDER] [varchar](10) 
 
	CONSTRAINT [PK_CUSTOMER] PRIMARY KEY NONCLUSTERED 
	(
	[ID] ASC
	) 
)

USE CRM_LOG
CREATE TABLE [dbo].[CUSTOMER](
	[ID] [int] ,
	[CUSTOMERNAME] [varchar](100),
	[CITY] [varchar](50),
	[DISTRICT] [varchar](50),
	[BIRTHDATE] [date],
	[GENDER] [varchar](10),
	[_LOG_DATE] [datetime] NULL, --LOG TARIHI
	[_LOG_USERNAME] [varchar](500) NULL,--İŞLEMİ YAPAN KULLANICI
	[_LOG_HOSTNAME] [varchar](500) NULL,--İŞLEM YAPILAN BİLGİSAYAR
	[_LOG_ACTIONTYPE] [varchar](10) NULL,--İŞLEM TÜRÜ UPDATE/DELETE
	[_LOG_PROGRAMNAME] [varchar](500) NULL,--İŞLEMİN YAPILDIĞI UYGULAMA
	[_LOG_SQL] [varchar](max) NULL,--İŞLEM YAPILAN SQL CÜMLESİ
	[_LOG_UPDATEDCOLUMNS] [varchar](max) NULL--DEĞİŞİM GÖREN KOLONLAR
	)
  
  CREATE TRIGGER TRG_LOG_CUSTOMER ON CUSTOMER 
AFTER UPDATE,DELETE
AS
BEGIN

/*
SQL SERVER DA TRIGGER İÇERİSİNDE DELETED VE INSERTED TABLOLARI OLUŞUR.
DELETE İŞLEMİNDE SİLİNEN KAYITLAR DELETED TABLOSUNDA TUTULUR, INSERTED TABLOSU BOŞTUR.
INSERT İŞLEMİNDE EKLENEN KAYITLAR INSERTED TABLOSUNDA TUTULUR, DELETED İŞLEMİ BOŞTUR
UPDATE İŞLEMİNDE SATIRIN YENİ BİLGİSİ INSERTED TABLOSUNDA, ESKİ BİLGİSİ INSERTED TABLOSUNDA TUTULUR.
BU BİLGİLERE GÖRE İŞLEMİN INSERT MÜ, UPDATE Mİ, YOKSA DELETE Mİ OLDUĞUNU ANLAYABİLİRİZ.
*/
SET NOCOUNT ON;
 
DECLARE @DELETECOUNT AS INT=0
DECLARE @INSERTCOUNT AS INT=0
DECLARE @UNIONCOUNT AS INT=0

DECLARE @LOG_SQL AS VARCHAR(MAX)
DECLARE @LOG_ACTIONTYPE AS VARCHAR(20)
 
SELECT @DELETECOUNT=COUNT(*) FROM DELETED 
SELECT @INSERTCOUNT=COUNT(*) FROM INSERTED

IF @DELETECOUNT=0 AND @INSERTCOUNT>0
	SET @LOG_ACTIONTYPE='I' --INSERT
IF @DELETECOUNT>0 AND @INSERTCOUNT=0
	SET @LOG_ACTIONTYPE='D' --DELETE 
IF @DELETECOUNT>0 AND @INSERTCOUNT>0
	SET @LOG_ACTIONTYPE='U' --UPDATE  

/******************************************************
KULLANICININ SON YAPTIĞI İŞLEMİ YAKALAMAK İÇİN DBCC INPUTBUFFER(@@SPID) KOMUTUNU KULLANIRIZ.
BU KOMUT BİR TABLO DÖNDÜRÜR. BURADA EVENTTYPE,PARAMETERS VE EVENTINFO ALANI GELİR.
EVENTINFO ALANI ÇALIŞTIRILAN SQL CÜMLESİDİR.
BURADA BU BİLGİYİ YAKALAMAK VE DEĞİŞKENE ATAMAK İÇİN TEMP TABLE KULLANIRIZ.
******************************************************/

CREATE TABLE #INPUTBUFFER (EVENTTYPE VARCHAR(100),PARAMETERS INT,EVENTINFO NVARCHAR(MAX))
INSERT INTO #INPUTBUFFER EXEC ('DBCC INPUTBUFFER(@@SPID)')

SELECT @LOG_SQL=EVENTINFO FROM #INPUTBUFFER

/******************************************************
DİĞER LOGLAMAK İSTEDİĞİMİZ BİLGİLER ZATEN FONKSİYON İLE YAKALANABİLİR.
"PROGRAME_NAME()" FONKSİYONU SQL SERVER'A HANGİ UYGULAMA İLE BAĞLANILDIĞINI GÖSTERİR.
CONNECTION STRING İÇERİSİNDE APPLICATION_NAME ALANINDA YAZAN ATTRIBUTE LERİ BURADAN YAKALARIZ.
BURADA WEB ÜZERİNDEN GELEN KULLANICILAR İÇİN KULLANICI IP'Sİ GİBİ BAŞKA BİLGİLER DE EKLENİP
GÖNDERİLİRSE BUNLAR DA KAYIT ALTINA ALINABİLİR.
******************************************************/

/******************************************************
SUSER_NAME() SQL'E BAĞLANAN KULLANICI ADI
HOST_NAME() BAĞLANAN MAKİNENİN ADI
GETDATE() ANLIK TARİH SAAT BİLGİSİ
******************************************************/

/****************************************************
TABLODA UPDATE İŞLEMİ VAR İSE INSERTED TABLOSUNDAKİ KAYITLAR İLE DELETED TABLOSUNDAKİ KAYITLARI
UNION İLE BİRLEŞTİRDİĞİMİZDE ELDE ETTİĞİMİZ KAYIT SAYISININ INSERTED TABLOSUNDAN BÜYÜK OLMASI GEREKİR
BUNU DA BİR DEĞİŞKENE ATACAĞIZ, UPDATE KONTROLÜNDE  LAZIM OLACAK
******************************************************/
SELECT @UNIONCOUNT=COUNT(*) FROM
(SELECT * FROM INSERTED 
UNION 
SELECT * FROM DELETED) T



/******************************************************
GERİYE UPDATE EDİLEN KOLONLARI YAKALAMAK KALDI. BU DURUMDA BİR KOLONUN UPDATE EDİLİP EDİLMEDİĞİNİ ANLAMAK
İÇİN YENİ VE ESKİ DEĞERLERİNİN KARŞILAŞTIRILMASI GEREKİYOR.
BUNUN İÇİN DE KOLON KOLON KARŞILAŞTIRMAK GEREKİYOR.
******************************************************/

--UPDATE İŞLEMİ İÇİN LOG TABLOMUZA İNSERT ATIYORUZ.
--BURADA @UNIONCOUNT>@INSERTCOUNT İSE EN AZ BİR KOLON GÜNCELLENMİŞTİR.
--AKABİNDE DEĞİŞEN KOLONLARI BULMAK İÇİN AŞAĞIDAKİ UZUN SQL CÜMLEMİZİ YAZIYORUZ.

IF @LOG_ACTIONTYPE='U' AND @UNIONCOUNT>@INSERTCOUNT
BEGIN  
	INSERT INTO CRM_LOG.DBO.CUSTOMER (
	ID,CUSTOMERNAME,CITY,DISTRICT,BIRTHDATE,GENDER, _LOG_DATE, _LOG_USERNAME, _LOG_HOSTNAME, _LOG_ACTIONTYPE, _LOG_PROGRAMNAME, _LOG_SQL,_LOG_UPDATEDCOLUMNS) 
	SELECT D.ID,D.CUSTOMERNAME,D.CITY,D.DISTRICT,D.BIRTHDATE,D.GENDER
	,GETDATE() AS _LOG_DATE,SUSER_NAME() AS _LOG_USERNAME,HOST_NAME() _LOG_HOSTNAME,@LOG_ACTIONTYPE _LOG_ACTIONTYPE,PROGRAM_NAME() _LOG_PROGRAMNAME,@LOG_SQL _LOG_SQL,CASE WHEN (I.ID<>D.ID) THEN   'ID,' ELSE '' END+CASE WHEN (I.CUSTOMERNAME<>D.CUSTOMERNAME) THEN   'CUSTOMERNAME,' ELSE '' END+CASE WHEN (I.CITY<>D.CITY) THEN   'CITY,' ELSE '' END+CASE WHEN (I.DISTRICT<>D.DISTRICT) THEN   'DISTRICT,' ELSE '' END+CASE WHEN (I.BIRTHDATE<>D.BIRTHDATE) THEN   'BIRTHDATE,' ELSE '' END+CASE WHEN (I.GENDER<>D.GENDER) THEN   'GENDER,' ELSE '' END
FROM DELETED D
LEFT JOIN INSERTED I 
ON I.ID=D.ID
END 


--DELETE İŞLEMİ İÇİN İŞİMİZ DAHA KOLAY. DOĞRUDAN LOG ATIYORUZ.

IF @LOG_ACTIONTYPE='D'  
BEGIN  
 
INSERT INTO CRM_LOG.DBO.CUSTOMER (
ID,CUSTOMERNAME,CITY,DISTRICT,BIRTHDATE,GENDER, _LOG_DATE, _LOG_USERNAME, _LOG_HOSTNAME, _LOG_ACTIONTYPE, _LOG_PROGRAMNAME, _LOG_SQL,_LOG_UPDATEDCOLUMNS) 
SELECT D.ID,D.CUSTOMERNAME,D.CITY,D.DISTRICT,D.BIRTHDATE,D.GENDER
,GETDATE() AS _LOG_DATE,SUSER_NAME() AS _LOG_USERNAME,HOST_NAME() _LOG_HOSTNAME,@LOG_ACTIONTYPE _LOG_ACTIONTYPE,PROGRAM_NAME() _LOG_PROGRAMNAME,@LOG_SQL _LOG_SQL,''
FROM DELETED D
END  
END

--SP for automation create log tbl

CREATE PROC [dbo].[CREATE_LOG_TABLE]
 @TABLENAME AS VARCHAR(1000)  ='CUSTOMER'
AS

DECLARE @DBNAME AS VARCHAR(1000)=''

 
 
DECLARE @SQL AS NVARCHAR(MAX)=''
DECLARE @COLUMNS AS VARCHAR(MAX)=''

DECLARE @COLUMN_NAME AS VARCHAR(200)
DECLARE CRS CURSOR FOR SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=@TABLENAME
OPEN CRS
FETCH NEXT FROM CRS INTO @COLUMN_NAME
WHILE @@FETCH_STATUS=0
BEGIN
IF @COLUMN_NAME='LOGICALREF'
	SET @COLUMN_NAME='CONVERT(INT,0) AS LOGICALREF'

SET @COLUMNS=@COLUMNS+@COLUMN_NAME+','	
		
FETCH NEXT FROM CRS INTO @COLUMN_NAME
END
CLOSE CRS
DEALLOCATE CRS 


--SET @COLUMNS=SUBSTRING(@COLUMNS,1,LEN(@COLUMNS)-1)
SET @COLUMNS=@COLUMNS+'CONVERT(DATETIME,NULL) AS _LOG_DATE,'
SET @COLUMNS=@COLUMNS+'CONVERT(VARCHAR(500),NULL) AS _LOG_USERNAME,'
SET @COLUMNS=@COLUMNS+'CONVERT(VARCHAR(500),NULL) AS _LOG_HOSTNAME,'
SET @COLUMNS=@COLUMNS+'CONVERT(VARCHAR(10),NULL) AS _LOG_ACTIONTYPE,'
SET @COLUMNS=@COLUMNS+'CONVERT(VARCHAR(500),NULL) AS _LOG_PROGRAMNAME,'
SET @COLUMNS=@COLUMNS+'CONVERT(VARCHAR(MAX),NULL) AS _LOG_SQL,'
SET @COLUMNS=@COLUMNS+'CONVERT(VARCHAR(MAX),NULL) AS _LOG_UPDATEDCOLUMNS'

SELECT @COLUMNS 
SET @SQL='IF NOT EXISTS (SELECT * FROM '+DB_NAME()+'_LOG.DBO.SYSOBJECTS WHERE XTYPE=''U'' AND NAME='''+@TABLENAME+''') SELECT TOP 0 '+@COLUMNS+' INTO '+DB_NAME()+'_LOG.DBO.'+@TABLENAME+' FROM '+@DBNAME+'.DBO.'+@TABLENAME 
 SELECT @SQL 
 EXEC SP_EXECUTESQL @SQL 
 
 --sp for automation creating trigger
 USE [CRM]
GO
/****** Object:  StoredProcedure [dbo].[CREATE_LOG_TRIGGER]    Script Date: 23.1.2020 17:30:11 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROC [dbo].[CREATE_LOG_TRIGGER] 
@TABLENAME AS VARCHAR(200)='CUSTOMER'
AS
DECLARE @SQL AS NVARCHAR(MAX)
 
SET @SQL='IF EXISTS (SELECT * FROM sys.triggers where NAME=''TRG_'+@TABLENAME+'_LOG'')  DROP TRIGGER  TRG_'+@TABLENAME+'_LOG
' 
EXEC SP_EXECUTESQL @SQL 

DECLARE @PRIMARYKEYCOLUMN AS VARCHAR(255)
SELECT 
    @PRIMARYKEYCOLUMN=COLUMN_NAME
FROM 
    INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
    JOIN 
    INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE ccu 
        ON tc.CONSTRAINT_NAME = ccu.Constraint_name
WHERE 
    tc.TABLE_NAME = @TABLENAME AND 
    tc.CONSTRAINT_TYPE = 'PRIMARY KEY'

SET @SQL='CREATE TRIGGER TRG_'+@TABLENAME+'_LOG ON '+@TABLENAME
SET @SQL=@SQL+'
AFTER UPDATE,DELETE'
SET @SQL=@SQL+'
AS'
SET @SQL=@SQL+'
BEGIN'
SET @SQL=@SQL+'
DECLARE @LOG_SQL AS VARCHAR(MAX)
DECLARE @LOG_ACTIONTYPE AS VARCHAR(20)
 
SET NOCOUNT ON;
DECLARE @INSERTCOUNT AS INT=0
DECLARE @DELETECOUNT AS INT=0
DECLARE @UNIONCOUNT AS INT=0

SELECT @INSERTCOUNT=COUNT(*) FROM INSERTED 
SELECT @DELETECOUNT=COUNT(*) FROM DELETED 
SELECT @UNIONCOUNT=COUNT(*) FROM
(SELECT * FROM INSERTED 
UNION 
SELECT * FROM DELETED) T'
SET @SQL=@SQL+'
IF @INSERTCOUNT>0 AND @DELETECOUNT>0
	SET @LOG_ACTIONTYPE=''U''
IF @INSERTCOUNT=0 AND @DELETECOUNT>0
	SET @LOG_ACTIONTYPE=''D''
IF @INSERTCOUNT>0 AND @DELETECOUNT=0
	SET @LOG_ACTIONTYPE=''I''
'
DECLARE @COLUMNS AS NVARCHAR(MAX)
DECLARE @COLUMNS2 AS NVARCHAR(MAX)
SELECT  @COLUMNS=(
  SELECT  
'D.'+COLUMN_NAME+','
 
  FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=@TABLENAME  FOR XML PATH('')
)
 
  SET @COLUMNS=REPLACE(@COLUMNS,'&lt;','<')
  SET @COLUMNS=REPLACE(@COLUMNS,'&Gt;','>')
  SET @COLUMNS=SUBSTRING(@COLUMNS,1,LEN(@COLUMNS)-1)


 
SELECT  @COLUMNS2=(
  SELECT  
 'CASE WHEN (I.'+COLUMN_NAME+'<>D.'+COLUMN_NAME+') THEN   '''+COLUMN_NAME+','' ELSE '''' END'++'+'   
 
  FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME=@TABLENAME
  FOR XML PATH('')
)

  SET @COLUMNS2=REPLACE(@COLUMNS2,'&lt;','<')
  SET @COLUMNS2=REPLACE(@COLUMNS2,'&Gt;','>')
  SET @COLUMNS2=SUBSTRING(@COLUMNS2,1,LEN(@COLUMNS2)-1)
 
SET @SQL=@SQL+ 'CREATE TABLE #INPUTBUFFER (EVENTTYPE VARCHAR(200),PARAMETERS VARCHAR(1000),EVENTINFO VARCHAR(MAX))
INSERT INTO #INPUTBUFFER EXEC(''DBCC INPUTBUFFER(@@SPID)'')
SELECT @LOG_SQL=EVENTINFO FROM #INPUTBUFFER 
DROP TABLE #INPUTBUFFER
'

SET @SQL=@SQL+ '
IF @LOG_ACTIONTYPE=''U'' AND @UNIONCOUNT>@INSERTCOUNT
BEGIN  
DECLARE @LASTREF AS BIGINT
'
SET @SQL=@SQL+ 'INSERT INTO '+DB_NAME()+'_LOG.DBO.'+@TABLENAME+' (
'
SET @SQL=@SQL+REPLACE(@COLUMNS,'D.','')+', _LOG_DATE, _LOG_USERNAME, _LOG_HOSTNAME, _LOG_ACTIONTYPE, _LOG_PROGRAMNAME, _LOG_SQL,_LOG_UPDATEDCOLUMNS) 
'

SET @SQL=@SQL+ 'SELECT '+@COLUMNS

SET @SQL=@SQL+ '
,GETDATE() AS _LOG_DATE,SUSER_NAME() AS _LOG_USERNAME,HOST_NAME() _LOG_HOSTNAME,@LOG_ACTIONTYPE _LOG_ACTIONTYPE,PROGRAM_NAME() _LOG_PROGRAMNAME,@LOG_SQL _LOG_SQL,'+@COLUMNS2

SET @SQL=@SQL+ '
FROM DELETED D
LEFT JOIN INSERTED I 
ON I.'+@PRIMARYKEYCOLUMN+'=D.'+@PRIMARYKEYCOLUMN+'
END 
'

SET @SQL=@SQL+ '
IF @LOG_ACTIONTYPE=''D''  
BEGIN  

'
SET @SQL=@SQL+ 'INSERT INTO '+DB_NAME()+'_LOG.DBO.'+@TABLENAME+' (
'
SET @SQL=@SQL+REPLACE(@COLUMNS,'D.','')+', _LOG_DATE, _LOG_USERNAME, _LOG_HOSTNAME, _LOG_ACTIONTYPE, _LOG_PROGRAMNAME, _LOG_SQL,_LOG_UPDATEDCOLUMNS) 
'
SET @SQL=@SQL+ 'SELECT '+@COLUMNS

SET @SQL=@SQL+ '
,GETDATE() AS _LOG_DATE,SUSER_NAME() AS _LOG_USERNAME,HOST_NAME() _LOG_HOSTNAME,@LOG_ACTIONTYPE _LOG_ACTIONTYPE,PROGRAM_NAME() _LOG_PROGRAMNAME,@LOG_SQL _LOG_SQL,'''''

SET @SQL=@SQL+ '
FROM DELETED D
 
END 
'
--------------------INSERT----------------
SET @SQL=@SQL+ '
IF @LOG_ACTIONTYPE=''I''  
BEGIN  
'
SET @SQL=@SQL+ 'INSERT INTO '+DB_NAME()+'_LOG.DBO.'+@TABLENAME+' (
'
SET @SQL=@SQL+REPLACE(@COLUMNS,'D.','')+', _LOG_DATE, _LOG_USERNAME, _LOG_HOSTNAME, _LOG_ACTIONTYPE, _LOG_PROGRAMNAME, _LOG_SQL,_LOG_UPDATEDCOLUMNS) 
'
SET @SQL=@SQL+ 'SELECT '+@COLUMNS

SET @SQL=@SQL+ '
,GETDATE() AS _LOG_DATE,SUSER_NAME() AS _LOG_USERNAME,HOST_NAME() _LOG_HOSTNAME,@LOG_ACTIONTYPE _LOG_ACTIONTYPE,PROGRAM_NAME() _LOG_PROGRAMNAME,@LOG_SQL _LOG_SQL,'''''

SET @SQL=@SQL+ '
FROM INSERTED D
 
END 
'

SET @SQL=@SQL+'
END
'
SELECT @COLUMNS,@SQL ,@COLUMNS2
 EXEC SP_EXECUTESQL @SQL 

-- query for table list (use excel for generating script)

SELECT 
'EXEC CRM.DBO.CREATE_LOG_TABLE '''+NAME+'''' AS SQL_,
NAME AS TABLENAME
 FROM SYSOBJECTS WHERE XTYPE='U'

SELECT 
'EXEC CRM.DBO.CREATE_LOG_TRIGGER '''+NAME+'''' AS SQL_,
NAME AS TABLENAME
 FROM SYSOBJECTS WHERE XTYPE='U'
